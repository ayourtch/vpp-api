/* Autogenerated data. Do not edit */
#![allow(non_camel_case_types)]
use bincode::Options;
use clap::Clap;
use serde::{de::DeserializeOwned, Deserialize, Serialize};
use vpp_api_encoding::typ::*;
use vpp_api_transport::*;
use vpp_api_transport::afunix;
use vpp_api_transport::shmem;
use vpp_api_transport::VppApiTransport;

#[derive(Debug, Clone, Clap, Serialize, Deserialize)]
#[clap(version = env!("GIT_VERSION"), author = "Andrew Yourtchenko <ayourtch@gmail.com>")]
struct Opts {
    /// Target hostname to do things on
    #[clap(short, long, default_value = "localhost")]
    target_host: String,

    /// Use AF_UNIX socket if this path is mentioned, else use shared mem
    #[clap(short, long)]
    socket_path: Option<String>,

    /// Override options from this yaml/json file
    #[clap(short, long)]
    options_override: Option<String>,

    /// set non-blocking mode for the connection
    #[clap(short, long)]
    nonblocking: bool,

    /// A level of verbosity, and can be used multiple times
    #[clap(short, long, parse(from_occurrences))]
    verbose: i32,
}

fn get_encoder() -> impl bincode::config::Options {
    bincode::DefaultOptions::new()
        .with_big_endian()
        .with_fixint_encoding()
}
fn send_recv_msg<'a, T: Serialize + Deserialize<'a>, TR: Serialize + DeserializeOwned>(
    name: &str,
    m: &T,
    t: &mut dyn VppApiTransport,
    reply_name: &str,
) -> TR {
    /* let vl_msg_id = t.get_msg_index(name).unwrap();
    let enc = get_encoder();
    let mut v = enc.serialize(&vl_msg_id).unwrap(); */
    let reply_vl_msg_id = t.get_msg_index(reply_name).unwrap();
    let enc = get_encoder();
    let mut v = enc.serialize(&m).unwrap();
    // v.extend_from_slice(&msg);
    // println!("MSG[{} = 0x{:x}]: {:?}", name, m.vl_msg_id, &v);
    match t.write(&v){
        Result::Err(_) => {println!("Failed to write to VPP")},
        Result::Ok(_) => {}
    }

    loop {
        let res = t.read_one_msg_id_and_msg();
        // dbg!(&res);
        if let Ok((msg_id, data)) = res {
            println!("id: {} data: {:x?}", msg_id, &data);
            if msg_id == reply_vl_msg_id {
                let res = get_encoder()
                    .allow_trailing_bytes()
                    .deserialize::<TR>(&data)
                    .unwrap();
                println!("Next thing will be the reply");
                return res;
            } else {
                println!("Checking the next message for the reply id");
            }
        } else {
            panic!("Result is an error: {:?}", &res);
        }
    }
}
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct version { 
	pub major : u32, 
	pub minor : u32, 
	pub patch : u32, 
	pub pre_release : u8, 
	pub build_metadata : u8, 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct thread_data { 
	pub id : u32, 
	pub name : String, 
	pub typ : String, 
	pub pid : u32, 
	pub cpu_id : u32, 
	pub core : u32, 
	pub cpu_socket : u32, 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
pub enum log_level { 
	 VPE_API_LOG_LEVEL_EMERG=0, 
	 VPE_API_LOG_LEVEL_ALERT=1, 
	 VPE_API_LOG_LEVEL_CRIT=2, 
	 VPE_API_LOG_LEVEL_ERR=3, 
	 VPE_API_LOG_LEVEL_WARNING=4, 
	 VPE_API_LOG_LEVEL_NOTICE=5, 
	 VPE_API_LOG_LEVEL_INFO=6, 
	 VPE_API_LOG_LEVEL_DEBUG=7, 
	 VPE_API_LOG_LEVEL_DISABLED=8, 
} 
pub type timestamp=f64; 
pub type timedelta=f64; 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct control_ping { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
} 
impl control_ping { 
	 pub fn get_message_id() -> String { 
	 	 String::from("control_ping_51077d14") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct control_ping_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : i32, 
	pub client_index : u32, 
	pub vpe_pid : u32, 
} 
impl control_ping_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("control_ping_reply_f6b0b8ca") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct cli { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
	pub cmd_in_shmem : u64, 
} 
impl cli { 
	 pub fn get_message_id() -> String { 
	 	 String::from("cli_23bfbfff") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct cli_inband { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
	pub cmd : String, 
} 
impl cli_inband { 
	 pub fn get_message_id() -> String { 
	 	 String::from("cli_inband_f8377302") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct cli_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : i32, 
	pub reply_in_shmem : u64, 
} 
impl cli_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("cli_reply_06d68297") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct cli_inband_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : i32, 
	pub reply : String, 
} 
impl cli_inband_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("cli_inband_reply_05879051") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_node_index { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
	pub node_name : String, 
} 
impl get_node_index { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_node_index_f1984c64") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_node_index_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : i32, 
	pub node_index : u32, 
} 
impl get_node_index_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_node_index_reply_a8600b89") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct add_node_next { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
	pub node_name : String, 
	pub next_name : String, 
} 
impl add_node_next { 
	 pub fn get_message_id() -> String { 
	 	 String::from("add_node_next_2457116d") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct add_node_next_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : i32, 
	pub next_index : u32, 
} 
impl add_node_next_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("add_node_next_reply_2ed75f32") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct show_version { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
} 
impl show_version { 
	 pub fn get_message_id() -> String { 
	 	 String::from("show_version_51077d14") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct show_version_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : i32, 
	pub program : String, 
	pub version : String, 
	pub build_date : String, 
	pub build_directory : String, 
} 
impl show_version_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("show_version_reply_c919bde1") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct show_threads { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
} 
impl show_threads { 
	 pub fn get_message_id() -> String { 
	 	 String::from("show_threads_51077d14") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct show_threads_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : i32, 
	pub count : u32, 
	pub thread_data : thread_data, 
} 
impl show_threads_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("show_threads_reply_efd78e83") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_node_graph { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
} 
impl get_node_graph { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_node_graph_51077d14") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_node_graph_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : i32, 
	pub reply_in_shmem : u64, 
} 
impl get_node_graph_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_node_graph_reply_06d68297") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_next_index { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
	pub node_name : String, 
	pub next_name : String, 
} 
impl get_next_index { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_next_index_2457116d") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_next_index_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : i32, 
	pub next_index : u32, 
} 
impl get_next_index_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_next_index_reply_2ed75f32") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct log_dump { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
	pub start_timestamp : timestamp, 
} 
impl log_dump { 
	 pub fn get_message_id() -> String { 
	 	 String::from("log_dump_6ab31753") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct log_details { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub timestamp : timestamp, 
	pub level : log_level, 
	pub msg_class : String, 
	pub message : String, 
} 
impl log_details { 
	 pub fn get_message_id() -> String { 
	 	 String::from("log_details_255827a1") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct show_vpe_system_time { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
} 
impl show_vpe_system_time { 
	 pub fn get_message_id() -> String { 
	 	 String::from("show_vpe_system_time_51077d14") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct show_vpe_system_time_reply { 
	pub context : u32, 
	pub retval : i32, 
	pub vpe_system_time : timestamp, 
} 
impl show_vpe_system_time_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("show_vpe_system_time_reply_7ffd8193") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_f64_endian_value { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
	pub f64_one : f64, 
} 
impl get_f64_endian_value { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_f64_endian_value_809fcd44") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_f64_endian_value_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : u32, 
	pub f64_one_result : f64, 
} 
impl get_f64_endian_value_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_f64_endian_value_reply_7e02e404") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_f64_increment_by_one { 
	pub vl_msg_id : u16, 
	pub client_index : u32, 
	pub context : u32, 
	pub f64_value : f64, 
} 
impl get_f64_increment_by_one { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_f64_increment_by_one_b64f027e") 
	 } 
} 
#[derive(Debug, Clone, Serialize, Deserialize)] 
struct get_f64_increment_by_one_reply { 
	pub vl_msg_id : u16, 
	pub context : u32, 
	pub retval : u32, 
	pub f64_value : f64, 
} 
impl get_f64_increment_by_one_reply { 
	 pub fn get_message_id() -> String { 
	 	 String::from("get_f64_increment_by_one_reply_d25dbaa3") 
	 } 
} 

fn main() {
    let opts: Opts = Opts::parse();

    // allow to load the options, so far there is no good built-in way
    let opts = if let Some(fname) = &opts.options_override {
        if let Ok(data) = std::fs::read_to_string(&fname) {
            let res = serde_json::from_str(&data);
            if res.is_ok() {
                res.unwrap()
            } else {
                serde_yaml::from_str(&data).unwrap()
            }
        } else {
            opts
        }
    } else {
        opts
    };

    if opts.verbose > 4 {
        let data = serde_json::to_string_pretty(&opts).unwrap();
        println!("{}", data);
        println!("===========");
        let data = serde_yaml::to_string(&opts).unwrap();
        println!("{}", data);
    }

    println!("Hello, here is your options: {:#?}", &opts);
    println!("Here is your interface reply");
    // test_func();
    // let mut t = shmem::Transport::new();
    // let mut t = afunix::Transport::new("/tmp/api.sock");
    let mut t: Box<dyn VppApiTransport> = if let Some(afunix_path) = &opts.socket_path {
        Box::new(afunix::Transport::new(&afunix_path))
    } else {
        Box::new(shmem::Transport::new())
    };

    println!("Connect result: {:?}", t.connect("api-test", None, 256));
    match t.set_nonblocking(opts.nonblocking){
        Result::Err(_err) => println!("Setting non blocking failed"),
        Result::Ok(_ok) => {}
    }

    let get_vpe_time: show_vpe_system_time_reply = send_recv_msg(
        &show_vpe_system_time::get_message_id(),
        &show_vpe_system_time{
            vl_msg_id: t.get_msg_index(&show_vpe_system_time::get_message_id()).unwrap(),
            client_index: t.get_client_index(),
            context: 0
        },
        &mut *t,
        &show_vpe_system_time_reply::get_message_id()
    );
    println!("Show VPE Time Reply: {:#?}", &get_vpe_time);
    // t.control_ping();
    //
    // bench(&mut *t);

    std::thread::sleep(std::time::Duration::from_secs(1));
    t.disconnect();

    // std::thread::sleep(std::time::Duration::from_secs(1));
}
